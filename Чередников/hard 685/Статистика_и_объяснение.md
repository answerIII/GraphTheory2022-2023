[Статистика на leetcode](https://leetcode.com/problems/merge-bsts-to-create-single-bst/submissions/939397422/)

Нам имеет смысл проверять только те узлы, у которых есть два входящих ребра, назовем такие узел кандидатом. По условию задачи у нас может быть не больше одного кандидата. После построения графа мы запускаем dfs в инвертированном графе, начиная поиск с родителя по первому ребру(ответ запоминаем в ans1), и повторно запускаем dfs по второму ребру(ответ запоминаем в ans2). Цель поиска - найти путь до вершины с двумя входящими ребрами. У нас может быть три варианта:
1) ans1 == True - тогда последнее встреченное ребро и есть ответ
2) ans2 == True && ans1 == False - тогда первое встреченное ребро и есть ответ
3) ans1 == False && ans2 == False - можно удалить любое ребро, но по условию задачи мы должны вернуть ребро, которое проверялось для ans1

Если у нас нет кандидата, то значит у нас есть какой-то цикл, в котором можно удалить любое ребро. Для нахождения такого цикла мы запускаем dfs на инвертированном графе аналогично случаю выше. Начинаем проверять ребра начиная с конца.
